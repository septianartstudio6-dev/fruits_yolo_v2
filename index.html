<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv8 Fruit Detection TF.js</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #222; color: white; text-align: center; margin: 0; padding: 20px; }
        h1 { margin-bottom: 10px; }
        .container { position: relative; display: inline-block; box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 12px; overflow: hidden; }
        video { display: block; width: 640px; height: 480px; object-fit: cover; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #status { font-size: 1.2em; margin-bottom: 20px; color: #00ffcc; }
        .controls { margin-top: 15px; }
    </style>
</head>
<body>

    <h1>Deteksi Buah Realtime (YOLOv8)</h1>
    <div id="status">Menyiapkan TF.js...</div>

    <div class="container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
        <p>Deteksi: 16 Kelas | Threshold: 25%</p>
    </div>

    <script>
        // --- KONFIGURASI USER ---
        const MODEL_URL = 'https://vkduvjyfrrjlckkk.public.blob.vercel-storage.com/model.json';
        const CONF_THRESHOLD = 0.25; // Threshold rendah (25%)
        const IOU_THRESHOLD = 0.45;  // Mencegah kotak tumpang tindih
        
        // DAFTAR NAMA KELAS (Wajib diisi sesuai urutan training Anda!)
        // Model Anda memiliki 16 kelas (Output channel 20 - 4 coord = 16)
        const CLASS_NAMES = [
            "Alpukat", "Anggur", "Apel", "Apel Hijau", 
            "Jeruk", "Lemon", "Mangga", "Melon",
            "Nanas", "Pepaya", "Pir", "Pisang",
            "Rambutan", "Salak", "Semangka", "Stroberi"
        ]; 

        let model;
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        // Warna random untuk setiap kelas
        const colors = CLASS_NAMES.map(() => '#' + Math.floor(Math.random()*16777215).toString(16));

        async function setupCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 },
                audio: false
            });
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    resolve();
                };
            });
        }

        async function loadModel() {
            statusDiv.innerText = "Memuat Model (sedikit lama)...";
            try {
                // Memuat model graph
                model = await tf.loadGraphModel(MODEL_URL);
                
                // Warmup model (mempercepat inferensi pertama)
                const dummy = tf.zeros([1, 640, 640, 3]);
                await model.executeAsync(dummy);
                tf.dispose(dummy);

                statusDiv.innerText = "Model Siap! Mendeteksi...";
                detectFrame();
            } catch (err) {
                console.error(err);
                statusDiv.innerText = "Error: Cek console (F12). Pastikan file model lengkap.";
            }
        }

        async function detectFrame() {
            if (!model) return;

            // 1. Preprocessing Input (Resize ke 640x640 & Normalisasi 0-1)
            const inputTensor = tf.tidy(() => {
                const img = tf.browser.fromPixels(video);
                return tf.image.resizeBilinear(img, [640, 640])
                    .div(255.0) // Normalisasi float 0-1
                    .expandDims(0); // Tambah batch dimension [1, 640, 640, 3]
            });

            try {
                const res = await model.executeAsync(inputTensor);
                
                // 2. Post-Processing YOLOv8 Output
                // Output shape model Anda: [1, 20, 8400]
                // Kita perlu transpose menjadi [1, 8400, 20] agar mudah diproses
                const transRes = res.transpose([0, 2, 1]); 
                const boxes = tf.tidy(() => {
                    const w = transRes.slice([0, 0, 2], [-1, -1, 1]); // Width
                    const h = transRes.slice([0, 0, 3], [-1, -1, 1]); // Height
                    const x = transRes.slice([0, 0, 0], [-1, -1, 1]); // Center X
                    const y = transRes.slice([0, 0, 1], [-1, -1, 1]); // Center Y
                    
                    // Convert [cx, cy, w, h] -> [y1, x1, y2, x2] untuk NMS
                    const y1 = y.sub(h.div(2));
                    const x1 = x.sub(w.div(2));
                    const y2 = y.add(h.div(2));
                    const x2 = x.add(w.div(2));
                    
                    return tf.concat([y1, x1, y2, x2], 2).squeeze(0); // [8400, 4]
                });

                const [scores, classes] = tf.tidy(() => {
                    // Ambil raw scores dari index 4 sampai akhir (16 kelas)
                    const rawScores = transRes.slice([0, 0, 4], [-1, -1, 16]).squeeze(0); // [8400, 16]
                    return [rawScores.max(1), rawScores.argMax(1)];
                });

                // 3. Non-Maximum Suppression (NMS)
                // Menyaring ribuan kotak menjadi deteksi unik
                const nms = await tf.image.nonMaxSuppressionAsync(boxes, scores, 50, IOU_THRESHOLD, CONF_THRESHOLD);
                
                const detIndices = nms.dataSync(); // Index kotak hasil deteksi
                
                // Ambil data untuk digambar
                const boxesData = boxes.dataSync();
                const scoresData = scores.dataSync();
                const classesData = classes.dataSync();

                renderPredictions(detIndices, boxesData, scoresData, classesData);

                // Bersihkan memori tensor
                tf.dispose([res, transRes, boxes, scores, classes, nms]);
            } catch (e) {
                console.error(e);
            }
            
            tf.dispose(inputTensor);
            requestAnimationFrame(detectFrame);
        }

        function renderPredictions(indices, boxes, scores, classes) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Faktor skala (Model 640x640 -> Ukuran Asli Canvas)
            const scaleX = canvas.width / 640;
            const scaleY = canvas.height / 640;

            for (let i = 0; i < indices.length; i++) {
                const idx = indices[i];
                const score = scores[idx];
                const labelIdx = classes[idx];
                const label = CLASS_NAMES[labelIdx] || `Class ${labelIdx}`;
                const color = colors[labelIdx] || 'red';

                // Koordinat box [y1, x1, y2, x2] dari TFJS
                const y1 = boxes[idx * 4] * scaleY;
                const x1 = boxes[idx * 4 + 1] * scaleX;
                const y2 = boxes[idx * 4 + 2] * scaleY;
                const x2 = boxes[idx * 4 + 3] * scaleX;

                const width = x2 - x1;
                const height = y2 - y1;

                // Gambar Kotak
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(x1, y1, width, height);

                // Gambar Label
                ctx.fillStyle = color;
                ctx.font = '16px Arial';
                const text = `${label} ${(score * 100).toFixed(0)}%`;
                const textWidth = ctx.measureText(text).width;
                
                ctx.fillRect(x1, y1 - 25, textWidth + 10, 25);
                ctx.fillStyle = '#fff';
                ctx.fillText(text, x1 + 5, y1 - 7);
            }
        }

        setupCamera().then(loadModel);
    </script>
</body>
</html>
