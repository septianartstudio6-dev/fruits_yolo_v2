<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>YOLOv8 Fruit Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        :root {
            --primary-color: #00ffcc;
            --bg-color: #121212;
            --panel-bg: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: #ffffff;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 { margin: 10px 0; font-size: 1.5rem; text-align: center; }

        /* Main Container for Video & Canvas */
        .video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            aspect-ratio: 4/3; /* Menjaga rasio agar tidak gepeng */
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,255,204, 0.2);
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Mirror effect for front camera facing user */
        video.mirror, canvas.mirror { transform: scaleX(-1); }

        /* UI Controls Panel */
        .controls-panel {
            width: 90%;
            max-width: 600px;
            margin-top: 15px;
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-group:last-child { margin-bottom: 0; }

        label { font-weight: 600; font-size: 0.9rem; }

        select, input[type=range] {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--primary-color);
            background: rgba(0,0,0,0.3);
            color: white;
            outline: none;
        }
        select { flex-grow: 1; margin-left: 10px; max-width: 60%; }
        input[type=range] { flex-grow: 1; margin: 0 10px; }

        #fps-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: var(--primary-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-family: monospace;
            z-index: 10;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 99;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid var(--panel-bg);
            border-top: 5px solid var(--primary-color); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-status">Menyiapkan TensorFlow.js...</div>
    </div>

    <h1>YOLOv8 Fruit Detection</h1>

    <div class="video-container">
        <div id="fps-display">FPS: 0</div>
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls-panel">
        <div class="control-group">
            <label for="camera-select">üì∑ Kamera:</label>
            <select id="camera-select">
                <option value="" disabled selected>Memuat kamera...</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="threshold-slider">üéöÔ∏è Threshold:</label>
            <input type="range" id="threshold-slider" min="0.1" max="0.9" step="0.05" value="0.5">
            <span id="threshold-value">50%</span>
        </div>
    </div>

    <script>
        // --- KONFIGURASI MODEL ---
        const MODEL_URL = 'https://vkduvjyfrrjlckkk.public.blob.vercel-storage.com/model.json';
        const MODEL_INPUT_SIZE = 640; // Ukuran input standar YOLOv8
        const IOU_THRESHOLD = 0.45;   // Untuk NMS (mencegah box tumpang tindih)
        
        // Nama Kelas dari metadata.yaml Anda (Urutan SANGAT PENTING)
        const CLASS_NAMES = [
            'Alpukat', 'Anggur', 'Apel', 'Apel Hijau', 'Jeruk', 'Lemon',
            'Mangga', 'Melon', 'Nanas', 'Pepaya', 'Pir', 'Pisang',
            'Rambutan', 'Salak', 'Semangka', 'Stroberi'
        ];

        // --- VARIABEL GLOBAL ---
        let model;
        let currentStream;
        let detectionThreshold = 0.5; // Default 50%
        let isDetecting = false;
        let lastFrameTime = 0;
        
        // DOM Elements
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingStatus = document.getElementById('loading-status');
        const cameraSelect = document.getElementById('camera-select');
        const thresholdSlider = document.getElementById('threshold-slider');
        const thresholdValue = document.getElementById('threshold-value');
        const fpsDisplay = document.getElementById('fps-display');
        
        // Warna untuk setiap kelas
        const colors = CLASS_NAMES.map(() => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'));

        // --- 1. INISIALISASI APLIKASI ---
        async function initApp() {
            try {
                // A. Setup Backend WebGL
                loadingStatus.innerText = "Mengaktifkan WebGL...";
                await tf.setBackend('webgl');
                await tf.ready();

                // B. Load Model
                loadingStatus.innerText = "Mengunduh & Memuat Model YOLOv8...";
                model = await tf.loadGraphModel(MODEL_URL);

                // C. Warmup Model (Pemanasan agar inferensi pertama cepat)
                loadingStatus.innerText = "Pemanasan Model (Warmup)...";
                const dummyInput = tf.zeros([1, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE, 3]);
                const warmupResult = await model.executeAsync(dummyInput);
                tf.dispose([dummyInput, warmupResult]); // Bersihkan memori

                // D. Setup Kamera
                loadingStatus.innerText = "Mencari Kamera...";
                await populateCameraList();
                await setupCamera(); // Default: Auto (Environment/Belakang)

                // Selesai
                loadingOverlay.style.display = 'none';
                isDetecting = true;
                detectFrame(); // Mulai loop deteksi

            } catch (error) {
                console.error("Initialization Error:", error);
                loadingStatus.innerText = `Error: ${error.message}. Cek Konsol.`;
                loadingStatus.style.color = 'red';
            }
        }

        // --- 2. FUNGSI KAMERA ---
        async function populateCameraList() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            
            cameraSelect.innerHTML = '';
            if (videoDevices.length === 0) {
                 cameraSelect.innerHTML = '<option>Tidak ada kamera ditemukan</option>';
                 return;
            }

            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Kamera ${index + 1}`;
                cameraSelect.appendChild(option);
            });
        }

        async function setupCamera(deviceId = null) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            // Konfigurasi constraints: Prioritaskan 'environment' (belakang) jika tidak ada ID spesifik
            const constraints = {
                video: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    facingMode: deviceId ? undefined : 'environment', 
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                },
                audio: false
            };

            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        // Sinkronkan ukuran canvas dengan video yang tampil
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;

                        // Cek facingMode untuk efek mirror
                        const track = currentStream.getVideoTracks()[0];
                        const settings = track.getSettings();
                        // Jika kamera depan ('user'), tambahkan class mirror
                        if (settings.facingMode === 'user') {
                            video.classList.add('mirror');
                            canvas.classList.add('mirror');
                        } else {
                            video.classList.remove('mirror');
                            canvas.classList.remove('mirror');
                        }

                        // Update dropdown ke kamera yang aktif
                        if (settings.deviceId) {
                             // Cari opsi yang sesuai dan set selected
                             Array.from(cameraSelect.options).forEach(opt => {
                                 if(opt.value === settings.deviceId) opt.selected = true;
                             });
                        }

                        resolve();
                    };
                });
            } catch (err) {
                alert("Gagal akses kamera: " + err.message);
                console.error(err);
            }
        }

        // --- 3. CORE DETEKSI (YOLOv8 Post-processing) ---
        async function detectFrame() {
            if (!isDetecting || video.readyState < 2) {
                requestAnimationFrame(detectFrame);
                return;
            }

            // Hitung FPS
            const now = performance.now();
            const fps = 1000 / (now - lastFrameTime);
            lastFrameTime = now;
            fpsDisplay.innerText = `FPS: ${fps.toFixed(1)}`;

            // --- A. Preprocessing & Inference (tf.tidy untuk manajemen memori otomatis) ---
            const [boxes, scores, classes] = tf.tidy(() => {
                const inputTensor = tf.browser.fromPixels(video)
                    .resizeBilinear([MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]) // Resize ke 640x640
                    .div(255.0) // Normalisasi [0,1]
                    .expandDims(0); // Batch dimension [1, 640, 640, 3]

                // RAW Output YOLOv8: [1, 20, 8400] -> [Batch, Channels, Anchors]
                const rawOutput = model.predict(inputTensor);

                // Transpose agar mudah diproses: [1, 8400, 20]
                const transposedOutput = rawOutput.transpose([0, 2, 1]).squeeze(0); // [8400, 20]

                // Pisahkan koordinat (4 kolom pertama) dan skor kelas (16 kolom sisanya)
                const rawBoxes = transposedOutput.slice([0, 0], [-1, 4]); // [cx, cy, w, h]
                const rawScores = transposedOutput.slice([0, 4], [-1, -1]); // 16 kelas

                // Cari skor tertinggi dan indeks kelasnya untuk setiap anchor
                const maxScores = rawScores.max(1); // Skor tertinggi per baris
                const maxClasses = rawScores.argMax(1); // Indeks kelas tertinggi

                // Konversi [cx, cy, w, h] ke [y1, x1, y2, x2] untuk NMS
                const boxesYXYX = tf.tidy(() => {
                    const cx = rawBoxes.slice([0, 0], [-1, 1]);
                    const cy = rawBoxes.slice([0, 1], [-1, 1]);
                    const w = rawBoxes.slice([0, 2], [-1, 1]);
                    const h = rawBoxes.slice([0, 3], [-1, 1]);
                    
                    const y1 = cy.sub(h.div(2));
                    const x1 = cx.sub(w.div(2));
                    const y2 = cy.add(h.div(2));
                    const x2 = cx.add(w.div(2));
                    return tf.concat([y1, x1, y2, x2], 1);
                });

                return [boxesYXYX, maxScores, maxClasses];
            });

            // --- B. Non-Max Suppression (Async) ---
            // Filter box yang tumpang tindih berdasarkan IoU dan Threshold
            const nmsIndices = await tf.image.nonMaxSuppressionAsync(
                boxes, scores, 
                50, // Max output boxes
                IOU_THRESHOLD, 
                detectionThreshold
            );
            
            // --- C. Ambil data hasil filter dari GPU ke CPU ---
            const validIndices = nmsIndices.dataSync();
            const boxesData = boxes.dataSync();
            const scoresData = scores.dataSync();
            const classesData = classes.dataSync();

            // Bersihkan semua tensor yang tidak ter-cover tf.tidy
            tf.dispose([boxes, scores, classes, nmsIndices]);

            // --- D. Render Hasil ---
            renderPredictions(validIndices, boxesData, scoresData, classesData);

            requestAnimationFrame(detectFrame);
        }

        function renderPredictions(indices, boxes, scores, classes) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Faktor skala untuk mengembalikan koordinat (dari 640x640 ke ukuran video asli)
            const scaleX = canvas.width / MODEL_INPUT_SIZE;
            const scaleY = canvas.height / MODEL_INPUT_SIZE;

            indices.forEach(idx => {
                const score = scores[idx];
                const classIdx = classes[idx];
                const label = CLASS_NAMES[classIdx] || 'Unknown';
                const color = colors[classIdx];

                // Koordinat [y1, x1, y2, x2] dikali skala
                const y1 = boxes[idx * 4] * scaleY;
                const x1 = boxes[idx * 4 + 1] * scaleX;
                const y2 = boxes[idx * 4 + 2] * scaleY;
                const x2 = boxes[idx * 4 + 3] * scaleX;
                const width = x2 - x1;
                const height = y2 - y1;

                // 1. Gambar Box
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                // Efek shadow agar lebih jelas
                ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                ctx.strokeRect(x1, y1, width, height);
                ctx.shadowBlur = 0;

                // 2. Gambar Latar Belakang Label
                ctx.fillStyle = color;
                const textStr = `${label} ${Math.round(score * 100)}%`;
                ctx.font = "bold 16px sans-serif";
                const textWidth = ctx.measureText(textStr).width;
                const textHeight = 22;
                // Gambar di atas box, kalau mentok atas pindah ke dalam
                const textY = y1 - textHeight < 0 ? y1 : y1 - textHeight;
                ctx.fillRect(x1, textY, textWidth + 8, textHeight);

                // 3. Gambar Teks
                ctx.fillStyle = "#000000"; // Teks hitam agar kontras
                ctx.fillText(textStr, x1 + 4, textY + 16);
            });
        }

        // --- EVENT LISTENERS ---
        // Ganti kamera saat dropdown berubah
        cameraSelect.addEventListener('change', (e) => {
            setupCamera(e.target.value);
        });

        // Update threshold saat slider digeser
        thresholdSlider.addEventListener('input', (e) => {
            detectionThreshold = parseFloat(e.target.value);
            thresholdValue.innerText = `${Math.round(detectionThreshold * 100)}%`;
        });

        // Mulai Aplikasi
        initApp();

    </script>
</body>
</html>
