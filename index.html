<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Fruit Detector Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        :root {
            --primary: #00ffcc;
            --bg: #1a1a1a;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: white;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            padding: 15px;
            text-align: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            position: absolute;
            top: 0;
            width: 100%;
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px var(--primary); }
        #status { font-size: 0.8rem; color: #ccc; margin-top: 5px; }

        /* Main Camera Area */
        .camera-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Mirror effect ONLY for front camera */
        .mirror { transform: scaleX(-1); }

        /* Floating HUD Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .control-group:last-child { margin-bottom: 0; }

        label { font-size: 0.9rem; font-weight: 600; color: #eee; }

        /* Styling Inputs */
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--primary);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            outline: none;
            font-size: 0.9rem;
            width: 60%;
        }

        /* Custom Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 50%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px var(--primary);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        #conf-value {
            font-family: monospace;
            color: var(--primary);
            width: 35px;
            text-align: right;
        }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">Memuat AI Model...</div>
    </div>

    <header>
        <h1>Fruit Scanner AI</h1>
        <div id="status">Menginisialisasi...</div>
    </header>

    <div class="camera-container">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="camera-select">Kamera</label>
            <select id="camera-select">
                <option value="" disabled selected>Mencari kamera...</option>
            </select>
        </div>

        <div class="control-group">
            <label for="conf-slider">Sensitivitas</label>
            <input type="range" id="conf-slider" min="0.1" max="1.0" step="0.05" value="0.25">
            <span id="conf-value">25%</span>
        </div>
    </div>

    <script>
        // --- KONFIGURASI ---
        const MODEL_URL = 'https://vkduvjyfrrjlckkk.public.blob.vercel-storage.com/model.json';
        const IOU_THRESHOLD = 0.15;
        
        // CLASS NAMES
        const CLASS_NAMES = [
            "Alpukat", "Anggur", "Apel", "Apel Hijau", 
            "Jeruk", "Lemon", "Mangga", "Melon",
            "Nanas", "Pepaya", "Pir", "Pisang",
            "Rambutan", "Salak", "Semangka", "Stroberi"
        ]; 

        // Variables
        let model;
        let currentStream;
        let CONF_THRESHOLD = 0.50; // Default Sensitivitas
        let isDetecting = false;

        // Elements
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const cameraSelect = document.getElementById('camera-select');
        const confSlider = document.getElementById('conf-slider');
        const confValue = document.getElementById('conf-value');
        const loader = document.getElementById('loader');

        const colors = CLASS_NAMES.map(() => '#' + Math.floor(Math.random()*16777215).toString(16));

        // --- HANDLERS ---
        confSlider.addEventListener('input', (e) => {
            CONF_THRESHOLD = parseFloat(e.target.value);
            confValue.innerText = Math.round(CONF_THRESHOLD * 100) + '%';
        });

        cameraSelect.addEventListener('change', (e) => {
            // Jika user memilih manual dari dropdown
            setupCamera(e.target.value);
        });

        // --- CAMERA FUNCTIONS (REVISED) ---

        async function getCameras() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true }); // Minta izin dulu
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                cameraSelect.innerHTML = ""; 
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Kamera ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
            } catch (error) {
                console.error("Gagal akses kamera:", error);
            }
        }

        async function setupCamera(deviceId = null) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            // --- LOGIKA UTAMA KAMERA BELAKANG ---
            let videoConstraints = {};

            if (deviceId) {
                // 1. Jika User memilih dari dropdown -> Pakai ID tersebut
                videoConstraints = { deviceId: { exact: deviceId } };
            } else {
                // 2. Jika Awal Buka (belum pilih) -> Pakai 'environment' (Kamera Belakang)
                videoConstraints = { facingMode: 'environment' };
            }

            const constraints = {
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    ...videoConstraints
                },
                audio: false
            };

            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;

                return new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // Cek apakah kamera depan atau belakang yang aktif
                        const track = currentStream.getVideoTracks()[0];
                        const settings = track.getSettings();
                        
                        // Update Dropdown agar sesuai dengan kamera yang dipilih otomatis
                        if (settings.deviceId && cameraSelect.options.length > 0) {
                             cameraSelect.value = settings.deviceId;
                        }

                        // Mirror efek hanya jika kamera depan (user facing)
                        if (settings.facingMode === 'user') {
                            video.classList.add('mirror');
                            canvas.classList.add('mirror');
                        } else {
                            video.classList.remove('mirror');
                            canvas.classList.remove('mirror');
                        }

                        resolve();
                    };
                });
            } catch (err) {
                alert("Gagal membuka kamera: " + err.message);
                // Fallback jika 'environment' gagal, coba kamera apa saja
                if (!deviceId) {
                   // setupCamera(null); // Warning: bisa infinite loop jika semua gagal
                }
            }
        }

        // --- MODEL & DETECTION ---

        async function init() {
            try {
                await tf.setBackend('webgl');
                model = await tf.loadGraphModel(MODEL_URL);
                
                // Warmup
                const dummy = tf.zeros([1, 640, 640, 3]);
                await model.executeAsync(dummy);
                tf.dispose(dummy);

                // 1. Isi Dropdown dulu
                await getCameras(); 

                // 2. Jalankan kamera (Tanpa ID -> Otomatis cari kamera belakang)
                await setupCamera(); 
                
                loader.style.opacity = '0';
                setTimeout(() => loader.remove(), 500);
                
                statusDiv.innerText = "Siap! Arahkan ke buah.";
                detectFrame();

            } catch (err) {
                console.error(err);
                document.getElementById('loading-text').innerText = "Gagal memuat Model.";
            }
        }

        async function detectFrame() {
            if (video.readyState < 2 || !model) {
                requestAnimationFrame(detectFrame);
                return;
            }

            // Preprocessing
            const inputTensor = tf.tidy(() => {
                 return tf.image.resizeBilinear(tf.browser.fromPixels(video), [640, 640])
                    .div(255.0).expandDims(0);
            });

            try {
                const res = await model.executeAsync(inputTensor);
                
                // Transpose & Process
                const transRes = res.transpose([0, 2, 1]);
                
                const boxes = tf.tidy(() => {
                    const w = transRes.slice([0, 0, 2], [-1, -1, 1]);
                    const h = transRes.slice([0, 0, 3], [-1, -1, 1]);
                    const x = transRes.slice([0, 0, 0], [-1, -1, 1]);
                    const y = transRes.slice([0, 0, 1], [-1, -1, 1]);
                    
                    const y1 = y.sub(h.div(2));
                    const x1 = x.sub(w.div(2));
                    const y2 = y.add(h.div(2));
                    const x2 = x.add(w.div(2));
                    return tf.concat([y1, x1, y2, x2], 2).squeeze(0);
                });

                const [scores, classes] = tf.tidy(() => {
                    const rawScores = transRes.slice([0, 0, 4], [-1, -1, 16]).squeeze(0);
                    return [rawScores.max(1), rawScores.argMax(1)];
                });

                const nms = await tf.image.nonMaxSuppressionAsync(boxes, scores, 50, IOU_THRESHOLD, CONF_THRESHOLD);
                const detIndices = nms.dataSync(); 

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const scaleX = canvas.width / 640;
                const scaleY = canvas.height / 640;
                
                const boxesArr = boxes.dataSync();
                const scoresArr = scores.dataSync();
                const classesArr = classes.dataSync();

                for (let i = 0; i < detIndices.length; i++) {
                    const idx = detIndices[i];
                    const score = scoresArr[idx];
                    const labelIdx = classesArr[idx];
                    const label = CLASS_NAMES[labelIdx] || 'Unknown';
                    const color = colors[labelIdx] || '#00ffcc';

                    const y1 = boxesArr[idx * 4] * scaleY;
                    const x1 = boxesArr[idx * 4 + 1] * scaleX;
                    const y2 = boxesArr[idx * 4 + 2] * scaleY;
                    const x2 = boxesArr[idx * 4 + 3] * scaleX;

                    const width = x2 - x1;
                    const height = y2 - y1;

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(x1, y1, width, height);
                    ctx.shadowBlur = 0; 

                    ctx.fillStyle = color;
                    const text = `${label} ${(score*100).toFixed(0)}%`;
                    const textW = ctx.measureText(text).width;
                    ctx.fillRect(x1, y1 - 25, textW + 10, 25);

                    ctx.fillStyle = '#000'; 
                    ctx.font = 'bold 16px Segoe UI';
                    ctx.fillText(text, x1 + 5, y1 - 7);
                }

                tf.dispose([res, transRes, boxes, scores, classes, nms]);

            } catch(e) {
                console.error(e);
            } finally {
                tf.dispose(inputTensor);
                requestAnimationFrame(detectFrame);
            }
        }

        init();
    </script>
</body>
</html>
